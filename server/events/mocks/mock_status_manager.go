// Code generated by pegomock. DO NOT EDIT.
// Source: github.com/runatlantis/atlantis/server/events/status (interfaces: StatusManager)

package mocks

import (
	"reflect"

	pegomock "github.com/petergtz/pegomock/v4"
	command "github.com/runatlantis/atlantis/server/events/command"
	models "github.com/runatlantis/atlantis/server/events/models"
	status "github.com/runatlantis/atlantis/server/events/status"
)

type MockStatusManager struct {
	fail func(message string, callerSkip ...int)
}

func NewMockStatusManager(options ...pegomock.Option) *MockStatusManager {
	mock := &MockStatusManager{}
	for _, option := range options {
		option.Apply(mock)
	}
	return mock
}

func (mock *MockStatusManager) SetFailHandler(fh pegomock.FailHandler) { mock.fail = fh }
func (mock *MockStatusManager) FailHandler() pegomock.FailHandler      { return mock.fail }

func (mock *MockStatusManager) HandleCommandStart(ctx *command.Context, cmdName command.Name) error {
	params := []pegomock.Param{ctx, cmdName}
	result := pegomock.GetGenericMockFrom(mock).Invoke("HandleCommandStart", params, []reflect.Type{reflect.TypeOf((*error)(nil)).Elem()})
	var ret0 error
	if len(result) != 0 {
		if result[0] != nil {
			ret0 = result[0].(error)
		}
	}
	return ret0
}

func (mock *MockStatusManager) HandleCommandEnd(ctx *command.Context, cmdName command.Name, result *command.Result) error {
	params := []pegomock.Param{ctx, cmdName, result}
	result_ := pegomock.GetGenericMockFrom(mock).Invoke("HandleCommandEnd", params, []reflect.Type{reflect.TypeOf((*error)(nil)).Elem()})
	var ret0 error
	if len(result_) != 0 {
		if result_[0] != nil {
			ret0 = result_[0].(error)
		}
	}
	return ret0
}

func (mock *MockStatusManager) HandleNoProjectsFound(ctx *command.Context, cmdName command.Name) error {
	params := []pegomock.Param{ctx, cmdName}
	result := pegomock.GetGenericMockFrom(mock).Invoke("HandleNoProjectsFound", params, []reflect.Type{reflect.TypeOf((*error)(nil)).Elem()})
	var ret0 error
	if len(result) != 0 {
		if result[0] != nil {
			ret0 = result[0].(error)
		}
	}
	return ret0
}

func (mock *MockStatusManager) SetPending(ctx *command.Context, cmdName command.Name) error {
	params := []pegomock.Param{ctx, cmdName}
	result := pegomock.GetGenericMockFrom(mock).Invoke("SetPending", params, []reflect.Type{reflect.TypeOf((*error)(nil)).Elem()})
	var ret0 error
	if len(result) != 0 {
		if result[0] != nil {
			ret0 = result[0].(error)
		}
	}
	return ret0
}

func (mock *MockStatusManager) SetSuccess(ctx *command.Context, cmdName command.Name, numSuccess int, numTotal int) error {
	params := []pegomock.Param{ctx, cmdName, numSuccess, numTotal}
	result := pegomock.GetGenericMockFrom(mock).Invoke("SetSuccess", params, []reflect.Type{reflect.TypeOf((*error)(nil)).Elem()})
	var ret0 error
	if len(result) != 0 {
		if result[0] != nil {
			ret0 = result[0].(error)
		}
	}
	return ret0
}

func (mock *MockStatusManager) SetFailure(ctx *command.Context, cmdName command.Name, err error) error {
	params := []pegomock.Param{ctx, cmdName, err}
	result := pegomock.GetGenericMockFrom(mock).Invoke("SetFailure", params, []reflect.Type{reflect.TypeOf((*error)(nil)).Elem()})
	var ret0 error
	if len(result) != 0 {
		if result[0] != nil {
			ret0 = result[0].(error)
		}
	}
	return ret0
}

func (mock *MockStatusManager) ClearAllStatuses(ctx *command.Context) error {
	params := []pegomock.Param{ctx}
	result := pegomock.GetGenericMockFrom(mock).Invoke("ClearAllStatuses", params, []reflect.Type{reflect.TypeOf((*error)(nil)).Elem()})
	var ret0 error
	if len(result) != 0 {
		if result[0] != nil {
			ret0 = result[0].(error)
		}
	}
	return ret0
}

func (mock *MockStatusManager) ClearStatusForCommand(ctx *command.Context, cmdName command.Name) error {
	params := []pegomock.Param{ctx, cmdName}
	result := pegomock.GetGenericMockFrom(mock).Invoke("ClearStatusForCommand", params, []reflect.Type{reflect.TypeOf((*error)(nil)).Elem()})
	var ret0 error
	if len(result) != 0 {
		if result[0] != nil {
			ret0 = result[0].(error)
		}
	}
	return ret0
}

func (mock *MockStatusManager) GetCurrentStatus(repo models.Repo, pull models.PullRequest) (*status.StatusState, error) {
	params := []pegomock.Param{repo, pull}
	result := pegomock.GetGenericMockFrom(mock).Invoke("GetCurrentStatus", params, []reflect.Type{reflect.TypeOf((**status.StatusState)(nil)).Elem(), reflect.TypeOf((*error)(nil)).Elem()})
	var ret0 *status.StatusState
	var ret1 error
	if len(result) != 0 {
		if result[0] != nil {
			ret0 = result[0].(*status.StatusState)
		}
		if result[1] != nil {
			ret1 = result[1].(error)
		}
	}
	return ret0, ret1
}
